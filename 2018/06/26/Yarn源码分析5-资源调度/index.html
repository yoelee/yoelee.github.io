<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="u51Tw-7XO-kfvd_YjNzNs4-HpCBkVQe3St8W8bIKI2w" />









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="hadoop,yarn,scheduler," />










<meta name="description" content="Yarn源码分析5-资源调度《Hadoop技术内幕-深入解析YARN架构设计与实现原理》学习笔记。  (Yarn源码基于Hadoop 3.0.0) Yarn源码小组讨论班2018-06-26 1. 基本架构资源调度器是最核心的组件之一，并且在yarn中是可插拔的，yarn中定义了一套接口规范，以方便用户实现自己的调度器，同时yarn中自带了FIFO，Capacity Sheduler， Fair">
<meta property="og:type" content="article">
<meta property="og:title" content="Yarn源码分析5-资源调度">
<meta property="og:url" content="https://yoelee.github.io/2018/06/26/Yarn%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/index.html">
<meta property="og:site_name" content="亚坤的博客">
<meta property="og:description" content="Yarn源码分析5-资源调度《Hadoop技术内幕-深入解析YARN架构设计与实现原理》学习笔记。  (Yarn源码基于Hadoop 3.0.0) Yarn源码小组讨论班2018-06-26 1. 基本架构资源调度器是最核心的组件之一，并且在yarn中是可插拔的，yarn中定义了一套接口规范，以方便用户实现自己的调度器，同时yarn中自带了FIFO，Capacity Sheduler， Fair">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-06-26T09:25:16.000Z">
<meta property="article:modified_time" content="2019-08-14T16:29:07.000Z">
<meta property="article:author" content="亚坤">
<meta property="article:tag" content="hadoop">
<meta property="article:tag" content="yarn">
<meta property="article:tag" content="scheduler">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoelee.github.io/2018/06/26/Yarn源码分析5-资源调度/"/>





  <title>Yarn源码分析5-资源调度 | 亚坤的博客</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">亚坤的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoelee.github.io/2018/06/26/Yarn%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亚坤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Yarn源码分析5-资源调度</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-26T17:25:16+08:00">
                2018-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">hadoop</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hadoop/yarn/" itemprop="url" rel="index">
                    <span itemprop="name">yarn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Yarn源码分析5-资源调度<br><em>《Hadoop技术内幕-深入解析YARN架构设计与实现原理》学习笔记。</em>  <em>(Yarn源码基于Hadoop 3.0.0)</em></p>
<p>Yarn源码小组讨论班<br>2018-06-26</p>
<h1 id="1-基本架构"><a href="#1-基本架构" class="headerlink" title="1. 基本架构"></a>1. 基本架构</h1><p>资源调度器是最核心的组件之一，并且在yarn中是可插拔的，yarn中定义了一套接口规范，以方便用户实现自己的调度器，同时yarn中自带了FIFO，Capacity Sheduler， Fair Scheduler三种常用资源调度器。</p>
<h2 id="1-1-调度模型"><a href="#1-1-调度模型" class="headerlink" title="1.1 调度模型"></a>1.1 调度模型</h2><p>Yarn的资源分配过程中异步的，也就是说调度器将资源分配给一个应用后，不会立刻通知AM，而是等AM的心跳主动来取。整个资源的分配过程可以概括为以下的步骤：</p>
<ul>
<li>1.NM通过心跳向RM汇报节点信息</li>
<li>2.RM按照一定策略将NM上的资源分配给应用(并没有直接分配，而是将结果放到一个内存数据结构)</li>
<li>3.应用AM向RM发心跳，以领取之前记录中在RM中的最新分配给自己的Container资源</li>
<li>4.应用AM向NM发起启动container的命令，将收到Container分配到内部的各个任务</li>
</ul>
<h2 id="1-2-资源保证机制"><a href="#1-2-资源保证机制" class="headerlink" title="1.2 资源保证机制"></a>1.2 资源保证机制</h2><p>当单个节点的闲置资源无法满足应用的一个container时，有两种策略：</p>
<ul>
<li>放弃当前节点等待下一个节点</li>
<li>在当前节点上预留一个Container申请，等到节点有资源时优先满足预留</li>
</ul>
<p>这两种机制都有优缺点：</p>
<ul>
<li>对于直接放弃的方案，可能会导致应用等待过久才能得到满足</li>
<li>对于预留的方案，会导致等待时间内的资源浪费，从而降低了资源利用率。</li>
</ul>
<p>Yarn使用了预留的方案。</p>
<h2 id="1-3-调度排序算法"><a href="#1-3-调度排序算法" class="headerlink" title="1.3 调度排序算法"></a>1.3 调度排序算法</h2><p>当有多个用户需要请求资源时，如果调度器的资源能满足所有请求，那么直接都给他们安排即可，可是，如果资源无法满足所有用户，那么就需要考虑一下资源如何分配是合理的。</p>
<p>Yarn中主要使用的是：主资源公平调度算法(Dominant Resource Fairness)，相关介绍参考：<a target="_blank" rel="noopener" href="http://yoelee.com/2018/02/24/Yarn%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">Yarn源码分析4-资源调度排序算法</a>.</p>
<h2 id="1-4-资源抢占模型"><a href="#1-4-资源抢占模型" class="headerlink" title="1.4 资源抢占模型"></a>1.4 资源抢占模型</h2><p>在资源调度器中，每个队列可设置一个最小资源量和最大资源量，其中</p>
<ul>
<li>最小资源量是资源紧缺情况下每个队列需要保证的资源量</li>
<li>最大资源量是在极端情况下队列也不能超过的资源使用量</li>
</ul>
<p>资源抢占发生的原因是为了保证队列的“最小资源量”。后续再专门梳理一下这部分的内容。</p>
<h2 id="1-5-队列层级管理"><a href="#1-5-队列层级管理" class="headerlink" title="1.5 队列层级管理"></a>1.5 队列层级管理</h2><p>队列层级管理具胡以下特点：</p>
<ul>
<li>子队列<ul>
<li>队列可以嵌套，每个队列均可以包含子队列。</li>
<li>用户只能将应用程序提交到叶子队列。</li>
</ul>
</li>
<li>最少容量（min share）<ul>
<li>每个子队列都有一个属性，表示可以占用父队列容量的百分比</li>
<li>调度器总是优先选择当前资源使用率最低的队列，并为之分配资源</li>
<li>最少容量不是总能保证的最低容量，需求低于这个值时是按需分配的</li>
<li>最少容量为正值，不能大于最大容量</li>
</ul>
</li>
<li>最大容量（max share）<ul>
<li>是一个队列资源使用的上限，任何时刻使用的资源总量不能超过此值</li>
<li>默认情况下最大容量是无限大</li>
</ul>
</li>
</ul>
<h1 id="2-NM通过心跳向RM汇报节点信息"><a href="#2-NM通过心跳向RM汇报节点信息" class="headerlink" title="2.NM通过心跳向RM汇报节点信息"></a>2.NM通过心跳向RM汇报节点信息</h1><p>NM中负责心跳的类是NodeStatusUpdater类型的成员变量nodeStatusUpdater，它在NM调用serviceInit的时候被创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeManager.java</span><br><span class="line">    <span class="keyword">if</span> (null == nodeLabelsProvider) &#123;</span><br><span class="line">      nodeStatusUpdater =</span><br><span class="line">          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      addIfService(nodeLabelsProvider);</span><br><span class="line">      nodeStatusUpdater =</span><br><span class="line">          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,</span><br><span class="line">              nodeLabelsProvider);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如上，根据是否使用nodeLabelsProvider有些参数上的区别(实例上调用的是同一个方法，只是nodeLabelsProvider在不声明时为空)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeManager.java</span><br><span class="line">  protected NodeStatusUpdater createNodeStatusUpdater(Context context,</span><br><span class="line">      Dispatcher dispatcher, NodeHealthCheckerService healthChecker) &#123;</span><br><span class="line">    <span class="keyword">return</span> new NodeStatusUpdaterImpl(context, dispatcher, healthChecker,</span><br><span class="line">        metrics, nodeLabelsProvider);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>NodeStatusUpdaterImpl是真正的负责与RM通讯的类，其中的serviceStart方法中会进行注册和心跳：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java</span><br><span class="line"><span class="meta">  @Override</span></span><br><span class="line">  protected void serviceStart() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // NodeManager <span class="keyword">is</span> the last service to start, so NodeId <span class="keyword">is</span> available.</span><br><span class="line">    this.nodeId = this.context.getNodeId();</span><br><span class="line">    LOG.info(<span class="string">&quot;Node ID assigned is : &quot;</span> + this.nodeId);</span><br><span class="line">    this.httpPort = this.context.getHttpPort();</span><br><span class="line">    this.nodeManagerVersionId = YarnVersionInfo.getVersion();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      // Registration has to be <span class="keyword">in</span> start so that ContainerManager can get the</span><br><span class="line">      // perNM tokens needed to authenticate ContainerTokens.</span><br><span class="line">      this.resourceTracker = getRMClient();</span><br><span class="line">      registerWithRM(); //向RM注册</span><br><span class="line">      <span class="built_in">super</span>.serviceStart();</span><br><span class="line">      startStatusUpdater(); //启动心跳线程</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      String errorMessage = <span class="string">&quot;Unexpected error starting NodeStatusUpdater&quot;</span>;</span><br><span class="line">      LOG.error(errorMessage, e);</span><br><span class="line">      throw new YarnRuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>向RM注册部分直接跳过了，这里重点看一下心跳：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java</span><br><span class="line">  protected void startStatusUpdater() &#123;</span><br><span class="line">    statusUpdaterRunnable = new StatusUpdaterRunnable();</span><br><span class="line">    statusUpdater =</span><br><span class="line">        new Thread(statusUpdaterRunnable, <span class="string">&quot;Node Status Updater&quot;</span>);</span><br><span class="line">    statusUpdater.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下StatusUpdaterRunnable的run方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      <span class="built_in">int</span> lastHeartbeatID = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!isStopped) &#123; //在被终止前死循环的跑</span><br><span class="line">        // Send heartbeat</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          NodeHeartbeatResponse response = null;</span><br><span class="line">          <span class="type">Set</span>&lt;NodeLabel&gt; nodeLabelsForHeartbeat =</span><br><span class="line">              nodeLabelsHandler.getNodeLabelsForHeartbeat();</span><br><span class="line">          NodeStatus nodeStatus = getNodeStatus(lastHeartbeatID);</span><br><span class="line">          NodeHeartbeatRequest request =</span><br><span class="line">              NodeHeartbeatRequest.newInstance(nodeStatus,</span><br><span class="line">                  NodeStatusUpdaterImpl.this.context</span><br><span class="line">                      .getContainerTokenSecretManager().getCurrentKey(),</span><br><span class="line">                  NodeStatusUpdaterImpl.this.context</span><br><span class="line">                      .getNMTokenSecretManager().getCurrentKey(),</span><br><span class="line">                  nodeLabelsForHeartbeat,</span><br><span class="line">                  NodeStatusUpdaterImpl.this.context</span><br><span class="line">                      .getRegisteringCollectors());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (logAggregationEnabled) &#123;</span><br><span class="line">            // pull log aggregation status <span class="keyword">for</span> application running <span class="keyword">in</span> this NM</span><br><span class="line">            <span class="type">List</span>&lt;LogAggregationReport&gt; logAggregationReports =</span><br><span class="line">                getLogAggregationReportsForApps(context</span><br><span class="line">                    .getLogAggregationStatusForApps());</span><br><span class="line">            <span class="keyword">if</span> (logAggregationReports != null</span><br><span class="line">                &amp;&amp; !logAggregationReports.isEmpty()) &#123;</span><br><span class="line">              request.setLogAggregationReportsForApps(logAggregationReports);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          //这里向RM发起RPC请求，并得到一个返回的结果response</span><br><span class="line">          response = resourceTracker.nodeHeartbeat(request);</span><br><span class="line">          //get <span class="built_in">next</span> heartbeat interval <span class="keyword">from</span> response</span><br><span class="line">          nextHeartBeatInterval = response.getNextHeartBeatInterval();</span><br><span class="line">          updateMasterKeys(response);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!handleShutdownOrResyncCommand(response)) &#123;</span><br><span class="line">            //省略很多行，这里是处理RM发来的停止运行或重新注册的情况</span><br><span class="line">          &#125;</span><br><span class="line">          // Handling node resource update <span class="keyword">case</span>.</span><br><span class="line">          Resource newResource = response.getResource();</span><br><span class="line">          <span class="keyword">if</span> (newResource != null) &#123;</span><br><span class="line">            updateNMResource(newResource);</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">              LOG.debug(<span class="string">&quot;Node&#x27;s resource is updated to &quot;</span> +</span><br><span class="line">                  newResource.toString());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (YarnConfiguration.timelineServiceV2Enabled(context.getConf())) &#123;</span><br><span class="line">            updateTimelineCollectorData(response);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ConnectException e) &#123;</span><br><span class="line">          //catch <span class="keyword">and</span> throw the exception <span class="keyword">if</span> tried MAX wait time to connect RM</span><br><span class="line">          dispatcher.getEventHandler().handle(</span><br><span class="line">              new NodeManagerEvent(NodeManagerEventType.SHUTDOWN));</span><br><span class="line">          // failed to connect to RM.</span><br><span class="line">          failedToConnect = true;</span><br><span class="line">          throw new YarnRuntimeException(e);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">          // TODO Better error handling. Thread can die <span class="keyword">with</span> the rest of the</span><br><span class="line">          // NM still running.</span><br><span class="line">          LOG.error(<span class="string">&quot;Caught exception in status-updater&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          synchronized (heartbeatMonitor) &#123;</span><br><span class="line">            nextHeartBeatInterval = nextHeartBeatInterval &lt;= <span class="number">0</span> ?</span><br><span class="line">                YarnConfiguration.DEFAULT_RM_NM_HEARTBEAT_INTERVAL_MS :</span><br><span class="line">                nextHeartBeatInterval;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              heartbeatMonitor.wait(nextHeartBeatInterval);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              // Do Nothing</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-RM收到心跳"><a href="#3-RM收到心跳" class="headerlink" title="3.RM收到心跳"></a>3.RM收到心跳</h1><p>RM中负责接收NM心跳的子服务是：ResourceTrackerService</p>
<p>下面直接看它的nodeHeartbeat方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java</span><br><span class="line">  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)</span><br><span class="line">      throws YarnException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    NodeStatus remoteNodeStatus = request.getNodeStatus();</span><br><span class="line">    /**</span><br><span class="line">     * 处理一个心中总共分为如下几步：</span><br><span class="line">     * <span class="number">1.</span> 判断它是否是一个合法的node（是否已经被拉黑过）</span><br><span class="line">     * <span class="number">2.</span> 判断它是否是一个注册过的node</span><br><span class="line">     * <span class="number">3.</span> 判断这个心跳是否是一个重复的心跳</span><br><span class="line">     * <span class="number">4.</span> 把NM的状态发个事件给RMNodeStatusEvent的处理器</span><br><span class="line">     * <span class="number">5.</span> 更新node label（如果分布式的label管理策略打开）</span><br><span class="line">     * <span class="number">6.</span> 判断是否是动态更新资源的节点</span><br><span class="line">     * <span class="number">7.</span> 发送排队的container的队列长度限制</span><br><span class="line">     */</span><br><span class="line">    // <span class="number">1</span>-<span class="number">3</span>步跳过</span><br><span class="line"></span><br><span class="line">    // <span class="number">4.</span> Send status to RMNode, saving the latest response.</span><br><span class="line">    RMNodeStatusEvent nodeStatusEvent =</span><br><span class="line">        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);</span><br><span class="line">    <span class="keyword">if</span> (request.getLogAggregationReportsForApps() != null</span><br><span class="line">        &amp;&amp; !request.getLogAggregationReportsForApps().isEmpty()) &#123;</span><br><span class="line">      nodeStatusEvent.setLogAggregationReportsForApps(request</span><br><span class="line">        .getLogAggregationReportsForApps());</span><br><span class="line">    &#125;</span><br><span class="line">    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);</span><br><span class="line"></span><br><span class="line">    // <span class="number">5</span>-<span class="number">7</span>步跳过</span><br><span class="line">    <span class="keyword">return</span> nodeHeartBeatResponse;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键是第4步，它会向RM中发送一个事件，这个事件的处理中会包含调度的过程。</p>
<h2 id="3-1-谁处理RMNodeStatusEvent"><a href="#3-1-谁处理RMNodeStatusEvent" class="headerlink" title="3.1 谁处理RMNodeStatusEvent"></a>3.1 谁处理RMNodeStatusEvent</h2><p>其中RMNodeStatusEvent继承自RMNodeEvent，RMNodeEvent在RM的注册处理器的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java</span><br><span class="line">      // Register event handler <span class="keyword">for</span> RmNodes</span><br><span class="line">      rmDispatcher.register(</span><br><span class="line">          RMNodeEventType.<span class="keyword">class</span>, new NodeEventDispatcher(rmContext));</span><br></pre></td></tr></table></figure>

<p>其中NodeEventDispatcher的handle方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java</span><br><span class="line">    public void handle(RMNodeEvent event) &#123;</span><br><span class="line">      NodeId nodeId = event.getNodeId();</span><br><span class="line">      RMNode node = this.rmContext.getRMNodes().get(nodeId);</span><br><span class="line">      <span class="keyword">if</span> (node != null) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ((EventHandler&lt;RMNodeEvent&gt;) node).handle(event);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">          LOG.error(<span class="string">&quot;Error in handling event type &quot;</span> + event.getType()</span><br><span class="line">              + <span class="string">&quot; for node &quot;</span> + nodeId, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用RMNode的handle方法，RMNodeRMNode是一个接口类，它的实现者是：RMNodeImpl，下面看一下它的handle方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java</span><br><span class="line">  public void handle(RMNodeEvent event) &#123;</span><br><span class="line">    LOG.debug(<span class="string">&quot;Processing &quot;</span> + event.getNodeId() + <span class="string">&quot; of type &quot;</span> + event.getType());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      writeLock.lock();</span><br><span class="line">      NodeState oldState = getState();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         stateMachine.doTransition(event.getType(), event);</span><br><span class="line">      &#125; catch (InvalidStateTransitionException e) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Can&#x27;t handle this event at current state&quot;</span>, e);</span><br><span class="line">        LOG.error(<span class="string">&quot;Invalid event &quot;</span> + event.getType() + </span><br><span class="line">            <span class="string">&quot; on Node  &quot;</span> + this.nodeId + <span class="string">&quot; oldState &quot;</span> + oldState);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (oldState != getState()) &#123;</span><br><span class="line">        LOG.info(nodeId + <span class="string">&quot; Node Transitioned from &quot;</span> + oldState + <span class="string">&quot; to &quot;</span></span><br><span class="line">                 + getState());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里会进入RMNodeImpl的状态机，由于RMNodeStatusEvent的事件类型是RMNodeEventType.STATUS_UPDATE，看一下状态中对这个事件的处理只有两种情况：</p>
<ul>
<li>从RUNNING到RUNNING、RUNNING，调用StatusUpdateWhenHealthyTransition</li>
<li>从DECOMMISSIONING到DECOMMISSIONING、DECOMMISSIONED，调用StatusUpdateWhenHealthyTransition</li>
<li>从UNHEALTHY到UNHEALTHY、RUNNING，调用StatusUpdateWhenUnHealthyTransition</li>
</ul>
<p>这里，选择最常见的情况，就是从RUNNING到RUNNING的情况，查看被调用的StatusUpdateWhenHealthyTransition的transition方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java</span><br><span class="line">    public NodeState transition(RMNodeImpl rmNode, RMNodeEvent event) &#123;</span><br><span class="line"></span><br><span class="line">      RMNodeStatusEvent statusEvent = (RMNodeStatusEvent) event;</span><br><span class="line">      rmNode.setOpportunisticContainersStatus(</span><br><span class="line">          statusEvent.getOpportunisticContainersStatus());</span><br><span class="line">      NodeHealthStatus remoteNodeHealthStatus = updateRMNodeFromStatusEvents(</span><br><span class="line">          rmNode, statusEvent);</span><br><span class="line">      NodeState initialState = rmNode.getState();</span><br><span class="line">        </span><br><span class="line">      //跳过unhealth和decommsission的判断的代码</span><br><span class="line"></span><br><span class="line">      rmNode.handleContainerStatus(statusEvent.getContainers());</span><br><span class="line">      rmNode.handleReportedIncreasedContainers(</span><br><span class="line">          statusEvent.getNMReportedIncreasedContainers());</span><br><span class="line"></span><br><span class="line">      <span class="type">List</span>&lt;LogAggregationReport&gt; logAggregationReportsForApps =</span><br><span class="line">          statusEvent.getLogAggregationReportsForApps();</span><br><span class="line">      <span class="keyword">if</span> (logAggregationReportsForApps != null</span><br><span class="line">          &amp;&amp; !logAggregationReportsForApps.isEmpty()) &#123;</span><br><span class="line">        rmNode.handleLogAggregationStatus(logAggregationReportsForApps);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(rmNode.nextHeartBeat) &#123;</span><br><span class="line">        rmNode.nextHeartBeat = false;</span><br><span class="line">        //敲黑板。这里是重点，向RM发送一个NodeUpdateSchedulerEvent事件 </span><br><span class="line">        rmNode.context.getDispatcher().getEventHandler().handle(</span><br><span class="line">            new NodeUpdateSchedulerEvent(rmNode));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Update DTRenewer <span class="keyword">in</span> secure mode to keep these apps alive. Today this <span class="keyword">is</span></span><br><span class="line">      // needed <span class="keyword">for</span> log-aggregation to finish long after the apps are gone.</span><br><span class="line">      <span class="keyword">if</span> (UserGroupInformation.isSecurityEnabled()) &#123;</span><br><span class="line">        rmNode.context.getDelegationTokenRenewer().updateKeepAliveApplications(</span><br><span class="line">          statusEvent.getKeepAliveAppIds());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> initialState;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里最关键是部分是向向RM发送一个NodeUpdateSchedulerEvent事件。</p>
<h2 id="3-2-谁处理NodeUpdateSchedulerEvent事件"><a href="#3-2-谁处理NodeUpdateSchedulerEvent事件" class="headerlink" title="3.2 谁处理NodeUpdateSchedulerEvent事件"></a>3.2 谁处理NodeUpdateSchedulerEvent事件</h2><p>NodeUpdateSchedulerEvent继承自SchedulerEvent，SchedulerEvent在RM中注册的处理器如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java</span><br><span class="line">      schedulerDispatcher = createSchedulerEventDispatcher();</span><br><span class="line">      addIfService(schedulerDispatcher);</span><br><span class="line">      rmDispatcher.register(SchedulerEventType.<span class="keyword">class</span>, schedulerDispatcher);</span><br></pre></td></tr></table></figure>

<p>其中createSchedulerEventDispatcher()代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java</span><br><span class="line">  protected EventHandler&lt;SchedulerEvent&gt; createSchedulerEventDispatcher() &#123;</span><br><span class="line">    <span class="keyword">return</span> new EventDispatcher(this.scheduler, <span class="string">&quot;SchedulerEventDispatcher&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中scheduler对象是根据配置yarn.resourcemanager.yarn.resourcemanager指定的类生成的对象，这里使用org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler。</p>
<p>下面进入FairScheduler的handle方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span><br><span class="line">  public void handle(SchedulerEvent event) &#123;</span><br><span class="line">    switch (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> NODE_ADDED://省略这部分逻辑</span><br><span class="line">    <span class="keyword">case</span> NODE_REMOVED://省略这部分逻辑</span><br><span class="line">    <span class="keyword">case</span> NODE_UPDATE:</span><br><span class="line">      <span class="keyword">if</span> (!(event instanceof NodeUpdateSchedulerEvent)) &#123;</span><br><span class="line">        throw new RuntimeException(<span class="string">&quot;Unexpected event type: &quot;</span> + event);</span><br><span class="line">      &#125;</span><br><span class="line">      NodeUpdateSchedulerEvent nodeUpdatedEvent = (NodeUpdateSchedulerEvent)event;</span><br><span class="line">      nodeUpdate(nodeUpdatedEvent.getRMNode());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> APP_ADDED://省略这部分逻辑</span><br><span class="line">    <span class="keyword">case</span> APP_REMOVED://省略这部分逻辑</span><br><span class="line">    <span class="keyword">case</span> NODE_RESOURCE_UPDATE://省略这部分逻辑</span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_ADDED://省略这部分逻辑</span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_REMOVED://省略这部分逻辑</span><br><span class="line">    <span class="keyword">case</span> CONTAINER_EXPIRED://省略这部分逻辑</span><br><span class="line">    default:</span><br><span class="line">      LOG.error(<span class="string">&quot;Unknown event arrived at FairScheduler: &quot;</span> + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于NodeUpdateSchedulerEvent的事件类型是SchedulerEventType.NODE_UPDATE，这里会进入NODE_UPDATE处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span><br><span class="line">  protected void nodeUpdate(RMNode nm) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      writeLock.lock();</span><br><span class="line">      long start = getClock().getTime();</span><br><span class="line">      eventLog.log(<span class="string">&quot;HEARTBEAT&quot;</span>, nm.getHostName());</span><br><span class="line">      <span class="built_in">super</span>.nodeUpdate(nm);</span><br><span class="line"></span><br><span class="line">      FSSchedulerNode fsNode = getFSSchedulerNode(nm.getNodeID());</span><br><span class="line">      attemptScheduling(fsNode);</span><br><span class="line"></span><br><span class="line">      long duration = getClock().getTime() - start;</span><br><span class="line">      fsOpDurations.addNodeUpdateDuration(duration);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，</p>
<ul>
<li>先调用父类的nodeUpdate()方法会进行container状态更新，和NM的状态的更新，这里跳过这部分逻辑。</li>
<li>然后获取了FSSchedulerNode的一个实例，并尝试进行调度。下面重点看一下这块逻辑。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span><br><span class="line">  void attemptScheduling(FSSchedulerNode node) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      writeLock.lock();</span><br><span class="line">      <span class="keyword">if</span> (rmContext.isWorkPreservingRecoveryEnabled() &amp;&amp; !rmContext</span><br><span class="line">          .isSchedulerReadyForAllocatingContainers()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final NodeId nodeID = node.getNodeID();</span><br><span class="line">      <span class="keyword">if</span> (!nodeTracker.exists(nodeID)) &#123;</span><br><span class="line">        // The node might have just been removed <span class="keyword">while</span> this thread was waiting</span><br><span class="line">        // on the synchronized lock before it entered this synchronized method</span><br><span class="line">        LOG.info(</span><br><span class="line">            <span class="string">&quot;Skipping scheduling as the node &quot;</span> + nodeID + <span class="string">&quot; has been removed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Assign new containers...</span><br><span class="line">      // <span class="number">1.</span> 先确认抢占的被分配</span><br><span class="line">      // <span class="number">2.</span> 再检查有没有reserved预留</span><br><span class="line">      // <span class="number">3.</span> 最后再进行调度分配新的container</span><br><span class="line"></span><br><span class="line">      // Apps may wait <span class="keyword">for</span> preempted containers</span><br><span class="line">      // We have to satisfy these first to avoid cases, when we preempt</span><br><span class="line">      // a container <span class="keyword">for</span> A <span class="keyword">from</span> B <span class="keyword">and</span> C gets the preempted containers,</span><br><span class="line">      // when C does <span class="keyword">not</span> qualify <span class="keyword">for</span> preemption itself.</span><br><span class="line">      assignPreemptedContainers(node);</span><br><span class="line">      FSAppAttempt reservedAppSchedulable = node.getReservedAppSchedulable();</span><br><span class="line">      boolean validReservation = false;</span><br><span class="line">      <span class="keyword">if</span> (reservedAppSchedulable != null) &#123;</span><br><span class="line">        validReservation = reservedAppSchedulable.assignReservedContainer(node);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!validReservation) &#123;</span><br><span class="line">        // No reservation, schedule at queue which <span class="keyword">is</span> farthest below fair share</span><br><span class="line">        <span class="built_in">int</span> assignedContainers = <span class="number">0</span>;</span><br><span class="line">        Resource assignedResource = Resources.clone(Resources.none());</span><br><span class="line">        Resource maxResourcesToAssign = Resources.multiply(</span><br><span class="line">            node.getUnallocatedResource(), <span class="number">0.5</span>f);</span><br><span class="line">        <span class="keyword">while</span> (node.getReservedContainer() == null) &#123;</span><br><span class="line">          //敲黑板，这里是分配的逻辑</span><br><span class="line">          Resource assignment = queueMgr.getRootQueue().assignContainer(node);</span><br><span class="line">          <span class="keyword">if</span> (assignment.equals(Resources.none())) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          assignedContainers++;</span><br><span class="line">          Resources.addTo(assignedResource, assignment);</span><br><span class="line">          <span class="keyword">if</span> (!shouldContinueAssigning(assignedContainers, maxResourcesToAssign,</span><br><span class="line">              assignedResource)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      updateRootQueueMetrics();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里不关注抢占和reserve机制，重点关注分配新container的部分，这里是调用queueMgr，找到RootQueue，然后调用了它的assignContainer(node)方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSParentQueue.java</span><br><span class="line">  public Resource assignContainer(FSSchedulerNode node) &#123;</span><br><span class="line">    Resource assigned = Resources.none();</span><br><span class="line"></span><br><span class="line">    // 超过了<span class="built_in">max</span> share就直接返回</span><br><span class="line">    <span class="keyword">if</span> (!assignContainerPreCheck(node)) &#123;</span><br><span class="line">      <span class="keyword">return</span> assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对所有的子队列进行排序</span><br><span class="line">    // 排序的策略在fair-scheduler.xml里面的配置项defaultQueueSchedulingPolicy决定，这里使用drf</span><br><span class="line">    // </span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Collections.sort(childQueues, policy.getComparator());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这里释放了写锁，加入了读锁 </span><br><span class="line">     * 这样可能会带来两个问题：</span><br><span class="line">     * <span class="number">1.</span> 新增了一个queue，不影响结果正确性，下次会再处理新queue</span><br><span class="line">     * <span class="number">2.</span> 删除了一个queue，这个最好处理一下，不过目前没有处理，也还好</span><br><span class="line">     */</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (FSQueue child : childQueues) &#123;</span><br><span class="line">        assigned = child.assignContainer(node);</span><br><span class="line">        <span class="keyword">if</span> (!Resources.equals(assigned, Resources.none())) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assigned;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>关于drf的思想参考：<a target="_blank" rel="noopener" href="http://yoelee.com/2018/02/24/Yarn%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">Yarn源码分析4-资源调度排序算法</a>.</p>
<p>这里重点介绍一下读锁内的assignContainer的部分：</p>
<ul>
<li>通过遍历所有孩子节点，递归的调用assignContainer方法。<ul>
<li>如果孩子节点是FSParentQueue类型，那么还是递归进入到跟刚才一样的逻辑中.</li>
<li>如果孩子节点是FSLeafQueue类型，那么进入到后面的逻辑：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSLeafQueue.java</span><br><span class="line">  public Resource assignContainer(FSSchedulerNode node) &#123;</span><br><span class="line">    Resource assigned = none();</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Node &quot;</span> + node.getNodeName() + <span class="string">&quot; offered to queue: &quot;</span> +</span><br><span class="line">          getName() + <span class="string">&quot; fairShare: &quot;</span> + getFairShare());</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查是否超过了<span class="built_in">max</span> share</span><br><span class="line">    <span class="keyword">if</span> (!assignContainerPreCheck(node)) &#123;</span><br><span class="line">      <span class="keyword">return</span> assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (FSAppAttempt sched : fetchAppsWithDemand(true)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SchedulerAppUtils.isPlaceBlacklisted(sched, node, LOG)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      assigned = sched.assignContainer(node);</span><br><span class="line">      <span class="keyword">if</span> (!assigned.equals(none())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;Assigned container in queue:&quot;</span> + getName() + <span class="string">&quot; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;container:&quot;</span> + assigned);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assigned;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面这块代码，有两个点需要重点关注：</p>
<ul>
<li>fetchAppsWithDemand：找到饥饿的app列表，并按照drf的策略进行排序，然后遍历</li>
<li>FSAppAttempt类的实例sched.assignContainer(node)方法，这里会进行container的分配，下面进入这块逻辑：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span><br><span class="line">  public Resource assignContainer(FSSchedulerNode node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOverAMShareLimit()) &#123;</span><br><span class="line">      PendingAsk amAsk = appSchedulingInfo.getNextPendingAsk();</span><br><span class="line">      updateAMDiagnosticMsg(amAsk.getPerAllocationResource(),</span><br><span class="line">          <span class="string">&quot; exceeds maximum AM resource allowed).&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;AM resource request: &quot;</span> + amAsk.getPerAllocationResource()</span><br><span class="line">            + <span class="string">&quot; exceeds maximum AM resource allowed, &quot;</span></span><br><span class="line">            + getQueue().dumpState());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Resources.none();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignContainer(node, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先判断是否达到了队列中可用于运行AM的资源比例限制，如果没有的话，继续跟进：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span><br><span class="line">  private Resource assignContainer(FSSchedulerNode node, boolean reserved) &#123;</span><br><span class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">      LOG.trace(<span class="string">&quot;Node offered to app: &quot;</span> + getName() + <span class="string">&quot; reserved: &quot;</span> + reserved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 按照priority进行排序</span><br><span class="line">    Collection&lt;SchedulerRequestKey&gt; keysToTry = (reserved) ?</span><br><span class="line">        Collections.singletonList(</span><br><span class="line">            node.getReservedContainer().getReservedSchedulerKey()) :</span><br><span class="line">        getSchedulerKeys();</span><br><span class="line"></span><br><span class="line">    // For each priority, see <span class="keyword">if</span> we can schedule a node local, rack local</span><br><span class="line">    // <span class="keyword">or</span> off-switch request. Rack of off-switch requests may be delayed</span><br><span class="line">    // (<span class="keyword">not</span> scheduled) <span class="keyword">in</span> order to promote better locality.</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      writeLock.lock();</span><br><span class="line"></span><br><span class="line">      // 按priority从高到低遍历所有的ResourceRequest</span><br><span class="line">      // 如果一个ResourceRequest可以在当前node上分配出来，就进入分配逻辑</span><br><span class="line">      <span class="keyword">for</span> (SchedulerRequestKey schedulerKey : keysToTry) &#123;</span><br><span class="line">        // 跳过无法在当前node上进行分配的请求。</span><br><span class="line">        // hasContainerForNode()这个函数会分node,rack,<span class="built_in">any</span>三种情况来考虑是否有合适的container。</span><br><span class="line">        // 并且也会考虑当前node上剩余的资源是否还足够分配</span><br><span class="line">        <span class="keyword">if</span> (!reserved &amp;&amp; !hasContainerForNode(schedulerKey, node)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 调度机会计数加<span class="number">1</span></span><br><span class="line">        addSchedulingOpportunity(schedulerKey);</span><br><span class="line"></span><br><span class="line">        PendingAsk rackLocalPendingAsk = getPendingAsk(schedulerKey,</span><br><span class="line">            node.getRackName());</span><br><span class="line">        PendingAsk nodeLocalPendingAsk = getPendingAsk(schedulerKey,</span><br><span class="line">            node.getNodeName());</span><br><span class="line"></span><br><span class="line">        // 如果有node级别的locality请求，并且不支持relaxLocality，那就给个warn。</span><br><span class="line">        <span class="keyword">if</span> (nodeLocalPendingAsk.getCount() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; !appSchedulingInfo.canDelayTo(schedulerKey,</span><br><span class="line">            node.getNodeName())) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Relax locality off is not supported on local request: &quot;</span></span><br><span class="line">              + nodeLocalPendingAsk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NodeType allowedLocality;</span><br><span class="line">        <span class="keyword">if</span> (scheduler.isContinuousSchedulingEnabled()) &#123;</span><br><span class="line">          allowedLocality = getAllowedLocalityLevelByTime(schedulerKey,</span><br><span class="line">              scheduler.getNodeLocalityDelayMs(),</span><br><span class="line">              scheduler.getRackLocalityDelayMs(),</span><br><span class="line">              scheduler.getClock().getTime());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          allowedLocality = getAllowedLocalityLevel(schedulerKey,</span><br><span class="line">              scheduler.getNumClusterNodes(),</span><br><span class="line">              scheduler.getNodeLocalityThreshold(),</span><br><span class="line">              scheduler.getRackLocalityThreshold());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果同时有node和rack级别的请求，就以NODE_LOCAL为参数进入下一步的assignContainer函数，并返回</span><br><span class="line">        <span class="keyword">if</span> (rackLocalPendingAsk.getCount() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; nodeLocalPendingAsk.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(<span class="string">&quot;Assign container on &quot;</span> + node.getNodeName()</span><br><span class="line">                + <span class="string">&quot; node, assignType: NODE_LOCAL&quot;</span> + <span class="string">&quot;, allowedLocality: &quot;</span></span><br><span class="line">                + allowedLocality + <span class="string">&quot;, priority: &quot;</span> + schedulerKey.getPriority()</span><br><span class="line">                + <span class="string">&quot;, app attempt id: &quot;</span> + this.attemptId);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> assignContainer(node, nodeLocalPendingAsk, NodeType.NODE_LOCAL,</span><br><span class="line">              reserved, schedulerKey);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果错过了上面的node级别，并且还不支持降级到rack级别，那就跳过这次调度机会</span><br><span class="line">        <span class="keyword">if</span> (!appSchedulingInfo.canDelayTo(schedulerKey, node.getRackName())) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 以RACK_LOCAL为参数进入下一步的assignContainer函数，并返回</span><br><span class="line">        <span class="keyword">if</span> (rackLocalPendingAsk.getCount() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; (allowedLocality.equals(NodeType.RACK_LOCAL) || allowedLocality</span><br><span class="line">            .equals(NodeType.OFF_SWITCH))) &#123;</span><br><span class="line">          <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(<span class="string">&quot;Assign container on &quot;</span> + node.getNodeName()</span><br><span class="line">                + <span class="string">&quot; node, assignType: RACK_LOCAL&quot;</span> + <span class="string">&quot;, allowedLocality: &quot;</span></span><br><span class="line">                + allowedLocality + <span class="string">&quot;, priority: &quot;</span> + schedulerKey.getPriority()</span><br><span class="line">                + <span class="string">&quot;, app attempt id: &quot;</span> + this.attemptId);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> assignContainer(node, rackLocalPendingAsk, NodeType.RACK_LOCAL,</span><br><span class="line">              reserved, schedulerKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PendingAsk offswitchAsk = getPendingAsk(schedulerKey,</span><br><span class="line">            ResourceRequest.ANY);</span><br><span class="line">        <span class="keyword">if</span> (!appSchedulingInfo.canDelayTo(schedulerKey, ResourceRequest.ANY)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 以OFF_SWITCH为参数进入下一步的assignContainer函数，并返回</span><br><span class="line">        <span class="keyword">if</span> (offswitchAsk.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (getAppPlacementAllocator(schedulerKey).getUniqueLocationAsks()</span><br><span class="line">              &lt;= <span class="number">1</span> || allowedLocality.equals(NodeType.OFF_SWITCH)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">              LOG.trace(<span class="string">&quot;Assign container on &quot;</span> + node.getNodeName()</span><br><span class="line">                  + <span class="string">&quot; node, assignType: OFF_SWITCH&quot;</span> + <span class="string">&quot;, allowedLocality: &quot;</span></span><br><span class="line">                  + allowedLocality + <span class="string">&quot;, priority: &quot;</span></span><br><span class="line">                  + schedulerKey.getPriority()</span><br><span class="line">                  + <span class="string">&quot;, app attempt id: &quot;</span> + this.attemptId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> assignContainer(node, offswitchAsk, NodeType.OFF_SWITCH,</span><br><span class="line">                reserved, schedulerKey);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">          LOG.trace(<span class="string">&quot;Can&#x27;t assign container on &quot;</span> + node.getNodeName()</span><br><span class="line">              + <span class="string">&quot; node, allowedLocality: &quot;</span> + allowedLocality + <span class="string">&quot;, priority: &quot;</span></span><br><span class="line">              + schedulerKey.getPriority() + <span class="string">&quot;, app attempt id: &quot;</span></span><br><span class="line">              + this.attemptId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Resources.none();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的的代码，主要逻辑是按priority从高到低的顺序遍历所有的ResourceRequest，针对每个ResourceRequest，在当前的node上面，找到适合它的locality，并将这个locality传入到下一级的assignContainer()函数中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span><br><span class="line">  private Resource assignContainer(</span><br><span class="line">      FSSchedulerNode node, PendingAsk pendingAsk, NodeType <span class="built_in">type</span>,</span><br><span class="line">      boolean reserved, SchedulerRequestKey schedulerKey) &#123;</span><br><span class="line"></span><br><span class="line">    // 当前的request需要多少资源</span><br><span class="line">    Resource capability = pendingAsk.getPerAllocationResource();</span><br><span class="line"></span><br><span class="line">    // 当前这个Node有多少资源</span><br><span class="line">    Resource available = node.getUnallocatedResource();</span><br><span class="line"></span><br><span class="line">    Container reservedContainer = null;</span><br><span class="line">    <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">      reservedContainer = node.getReservedContainer().getContainer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 资源够分配的</span><br><span class="line">    <span class="keyword">if</span> (Resources.fitsIn(capability, available)) &#123;</span><br><span class="line">      // 划重点：分配一个container出来</span><br><span class="line">      RMContainer allocatedContainer =</span><br><span class="line">          allocate(<span class="built_in">type</span>, node, schedulerKey, pendingAsk,</span><br><span class="line">              reservedContainer);</span><br><span class="line">      <span class="keyword">if</span> (allocatedContainer == null) &#123;</span><br><span class="line">        // Did the application need this resource?</span><br><span class="line">        <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">          unreserve(schedulerKey, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Resources.none();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If we had previously made a reservation, delete it</span><br><span class="line">      <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">        unreserve(schedulerKey, node);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Inform the node</span><br><span class="line">      node.allocateContainer(allocatedContainer);</span><br><span class="line"></span><br><span class="line">      // If <span class="keyword">not</span> running unmanaged, the first container we allocate <span class="keyword">is</span> always</span><br><span class="line">      // the AM. <span class="type">Set</span> the amResource <span class="keyword">for</span> this app <span class="keyword">and</span> update the leaf queue<span class="string">&#x27;s AM</span></span><br><span class="line"><span class="string">      // usage</span></span><br><span class="line"><span class="string">      if (!isAmRunning() &amp;&amp; !getUnmanagedAM()) &#123;</span></span><br><span class="line"><span class="string">        setAMResource(capability);</span></span><br><span class="line"><span class="string">        getQueue().addAMResourceUsage(capability);</span></span><br><span class="line"><span class="string">        setAmRunning(true);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      return capability;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 以下逻辑，是资源不够分配的情况，判断一下是否需要reserve</span></span><br><span class="line"><span class="string">    if (LOG.isDebugEnabled()) &#123;</span></span><br><span class="line"><span class="string">      LOG.debug(&quot;Resource request: &quot; + capability + &quot; exceeds the available&quot;</span></span><br><span class="line"><span class="string">          + &quot; resources of the node.&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (isReservable(capability) &amp;&amp; //如果应用比较饥饿，并且请求的资源超过了一定大小</span></span><br><span class="line"><span class="string">        !node.isPreemptedForApp(this) &amp;&amp; //不准备在这个节点进行抢占，否则有可能有多个Reserve</span></span><br><span class="line"><span class="string">        reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,</span></span><br><span class="line"><span class="string">            type, schedulerKey)) &#123;</span></span><br><span class="line"><span class="string">      updateAMDiagnosticMsg(capability, &quot; exceeds the available resources of &quot;</span></span><br><span class="line"><span class="string">          + &quot;the node and the request is reserved)&quot;);</span></span><br><span class="line"><span class="string">      if (LOG.isDebugEnabled()) &#123;</span></span><br><span class="line"><span class="string">        LOG.debug(getName() + &quot;&#x27;</span>s resource request <span class="keyword">is</span> reserved.<span class="string">&quot;);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      return FairScheduler.CONTAINER_RESERVED;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">      updateAMDiagnosticMsg(capability, &quot;</span> exceeds the available resources of <span class="string">&quot;</span></span><br><span class="line"><span class="string">          + &quot;</span>the node <span class="keyword">and</span> the request cannot be reserved)<span class="string">&quot;);</span></span><br><span class="line"><span class="string">      if (LOG.isDebugEnabled()) &#123;</span></span><br><span class="line"><span class="string">        LOG.debug(&quot;</span>Couldn<span class="string">&#x27;t create reservation for app:  &quot; + getName()</span></span><br><span class="line"><span class="string">            + &quot;, at priority &quot; +  schedulerKey.getPriority());</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      return Resources.none();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，主要是看一下能否分配一个container出来，如果不能话，那么看一下能否进行一次reserve。</p>
<p>这是重点关注分配一个container出来的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span><br><span class="line">  public RMContainer allocate(NodeType <span class="built_in">type</span>, FSSchedulerNode node,</span><br><span class="line">      SchedulerRequestKey schedulerKey, PendingAsk pendingAsk,</span><br><span class="line">      Container reservedContainer) &#123;</span><br><span class="line">    RMContainer rmContainer;</span><br><span class="line">    Container container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      writeLock.lock();</span><br><span class="line">      // Update allowed locality level</span><br><span class="line">      NodeType allowed = allowedLocalityLevel.get(schedulerKey);</span><br><span class="line">      <span class="keyword">if</span> (allowed != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allowed.equals(NodeType.OFF_SWITCH) &amp;&amp; (<span class="built_in">type</span>.equals(</span><br><span class="line">            NodeType.NODE_LOCAL) || <span class="built_in">type</span>.equals(NodeType.RACK_LOCAL))) &#123;</span><br><span class="line">          this.resetAllowedLocalityLevel(schedulerKey, <span class="built_in">type</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowed.equals(NodeType.RACK_LOCAL) &amp;&amp; <span class="built_in">type</span>.equals(</span><br><span class="line">            NodeType.NODE_LOCAL)) &#123;</span><br><span class="line">          this.resetAllowedLocalityLevel(schedulerKey, <span class="built_in">type</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Required sanity check - AM can call <span class="string">&#x27;allocate&#x27;</span> to update resource</span><br><span class="line">      // request without locking the scheduler, hence we need to check</span><br><span class="line">      <span class="keyword">if</span> (getOutstandingAsksCount(schedulerKey) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      container = reservedContainer;</span><br><span class="line">      <span class="keyword">if</span> (container == null) &#123;</span><br><span class="line">        // 敲黑板，这里会创建一个container实例出来。</span><br><span class="line">        container = createContainer(node, pendingAsk.getPerAllocationResource(),</span><br><span class="line">            schedulerKey);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 下面的逻辑是记录这个新创建出来的container</span><br><span class="line">      // Create RMContainer</span><br><span class="line">      rmContainer = new RMContainerImpl(container, schedulerKey,</span><br><span class="line">          getApplicationAttemptId(), node.getNodeID(),</span><br><span class="line">          appSchedulingInfo.getUser(), rmContext);</span><br><span class="line">      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());</span><br><span class="line"></span><br><span class="line">      // 重点关注：这里会把rmContainer记录下来，等待下次AM心跳时，会从这里把分配出来的container带走</span><br><span class="line">      addToNewlyAllocatedContainers(node, rmContainer);</span><br><span class="line">      liveContainers.put(container.getId(), rmContainer);</span><br><span class="line"></span><br><span class="line">      // Update consumption <span class="keyword">and</span> track allocations</span><br><span class="line">      <span class="type">List</span>&lt;ResourceRequest&gt; resourceRequestList = appSchedulingInfo.allocate(</span><br><span class="line">          <span class="built_in">type</span>, node, schedulerKey, container);</span><br><span class="line">      this.attemptResourceUsage.incUsed(container.getResource());</span><br><span class="line">      getQueue().incUsedResource(container.getResource());</span><br><span class="line"></span><br><span class="line">      // Update resource requests related to <span class="string">&quot;request&quot;</span> <span class="keyword">and</span> store <span class="keyword">in</span> RMContainer</span><br><span class="line">      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);</span><br><span class="line"></span><br><span class="line">      // Inform the container</span><br><span class="line">      rmContainer.handle(</span><br><span class="line">          new RMContainerEvent(container.getId(), RMContainerEventType.START));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;allocate: applicationAttemptId=&quot;</span> + container.getId()</span><br><span class="line">            .getApplicationAttemptId() + <span class="string">&quot; container=&quot;</span> + container.getId()</span><br><span class="line">            + <span class="string">&quot; host=&quot;</span> + container.getNodeId().getHost() + <span class="string">&quot; type=&quot;</span> + <span class="built_in">type</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,</span><br><span class="line">          <span class="string">&quot;SchedulerApp&quot;</span>, getApplicationId(), container.getId(),</span><br><span class="line">          container.getResource());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmContainer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-AM向RM发心跳认领资源"><a href="#4-AM向RM发心跳认领资源" class="headerlink" title="4.AM向RM发心跳认领资源"></a>4.AM向RM发心跳认领资源</h1><p>经过上面的过程，已经能将分配给APP的container记录在RM内存中了。接下来就是AM的心跳领取分配给自己的资源，并用来计算的过程了。</p>
<h2 id="4-1-AM发起请求"><a href="#4-1-AM发起请求" class="headerlink" title="4.1 AM发起请求"></a>4.1 AM发起请求</h2><p>由于各个计算引擎的AM逻辑不同，这里使用通用的接口方法为入口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/api/ApplicationMasterProtocol.java</span><br><span class="line">  public AllocateResponse allocate(AllocateRequest request) </span><br><span class="line">  throws YarnException, IOException;</span><br></pre></td></tr></table></figure>

<p>各个计算引擎的AM是通过allocate()这个API来向RM发起RPC请求获取计算资源，下面看一下RM是如何处理这个RPC请求的。</p>
<h2 id="4-2-RM处理AM请求"><a href="#4-2-RM处理AM请求" class="headerlink" title="4.2 RM处理AM请求"></a>4.2 RM处理AM请求</h2><p>RM中负责处理AM心跳请求的服务是：ApplicationMasterService，其内部的allocate()负责处理AM的RPC请求，具体逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java</span><br><span class="line">  public AllocateResponse allocate(AllocateRequest request)</span><br><span class="line">      throws YarnException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    AMRMTokenIdentifier amrmTokenIdentifier =</span><br><span class="line">        YarnServerSecurityUtils.authorizeRequest();</span><br><span class="line"></span><br><span class="line">    ApplicationAttemptId appAttemptId =</span><br><span class="line">        amrmTokenIdentifier.getApplicationAttemptId();</span><br><span class="line"></span><br><span class="line">    this.amLivelinessMonitor.receivedPing(appAttemptId);</span><br><span class="line"></span><br><span class="line">    /* 针对每个appAttempt,会有一个独立的锁对象</span><br><span class="line">    AllocateResponseLock lock = responseMap.get(appAttemptId);</span><br><span class="line">    <span class="keyword">if</span> (lock == null) &#123;</span><br><span class="line">      String message =</span><br><span class="line">          <span class="string">&quot;Application attempt &quot;</span> + appAttemptId</span><br><span class="line">              + <span class="string">&quot; doesn&#x27;t exist in ApplicationMasterService cache.&quot;</span>;</span><br><span class="line">      LOG.error(message);</span><br><span class="line">      throw new ApplicationAttemptNotFoundException(message);</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">      AllocateResponse lastResponse = lock.getAllocateResponse();</span><br><span class="line">      <span class="keyword">if</span> (!hasApplicationMasterRegistered(appAttemptId)) &#123;</span><br><span class="line">        String message =</span><br><span class="line">            <span class="string">&quot;AM is not registered for known application attempt: &quot;</span></span><br><span class="line">                + appAttemptId</span><br><span class="line">                + <span class="string">&quot; or RM had restarted after AM registered. &quot;</span></span><br><span class="line">                + <span class="string">&quot; AM should re-register.&quot;</span>;</span><br><span class="line">        throw new ApplicationMasterNotRegisteredException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Normally request.getResponseId() == lastResponse.getResponseId()</span><br><span class="line">      <span class="keyword">if</span> (getNextResponseId(request.getResponseId()) == lastResponse</span><br><span class="line">          .getResponseId()) &#123;</span><br><span class="line">        // heartbeat one step old, simply <span class="keyword">return</span> lastReponse</span><br><span class="line">        <span class="keyword">return</span> lastResponse;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getResponseId() != lastResponse.getResponseId()) &#123;</span><br><span class="line">        String message =</span><br><span class="line">            <span class="string">&quot;Invalid responseId in AllocateRequest from application attempt: &quot;</span></span><br><span class="line">                + appAttemptId + <span class="string">&quot;, expect responseId to be &quot;</span></span><br><span class="line">                + lastResponse.getResponseId() + <span class="string">&quot;, but get &quot;</span></span><br><span class="line">                + request.getResponseId();</span><br><span class="line">        throw new InvalidApplicationMasterRequestException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      AllocateResponse response =</span><br><span class="line">          recordFactory.newRecordInstance(AllocateResponse.<span class="keyword">class</span>);</span><br><span class="line">        </span><br><span class="line">      // 这里是这次申请资源的处理关键点</span><br><span class="line">      // 通过这个方法，会把分配的container填入到response对象中</span><br><span class="line">      // ProcessingChain这个名字是不是很眼熟？就是设计模式中的责任链</span><br><span class="line">      this.amsProcessingChain.allocate(</span><br><span class="line">          amrmTokenIdentifier.getApplicationAttemptId(), request, response);</span><br><span class="line"></span><br><span class="line">      // update AMRMToken <span class="keyword">if</span> the token <span class="keyword">is</span> rolled-up</span><br><span class="line">      MasterKeyData nextMasterKey =</span><br><span class="line">          this.rmContext.getAMRMTokenSecretManager().getNextMasterKeyData();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextMasterKey != null</span><br><span class="line">          &amp;&amp; nextMasterKey.getMasterKey().getKeyId() != amrmTokenIdentifier</span><br><span class="line">          .getKeyId()) &#123;</span><br><span class="line">        RMApp app =</span><br><span class="line">            this.rmContext.getRMApps().get(appAttemptId.getApplicationId());</span><br><span class="line">        RMAppAttempt appAttempt = app.getRMAppAttempt(appAttemptId);</span><br><span class="line">        RMAppAttemptImpl appAttemptImpl = (RMAppAttemptImpl)appAttempt;</span><br><span class="line">        Token&lt;AMRMTokenIdentifier&gt; amrmToken = appAttempt.getAMRMToken();</span><br><span class="line">        <span class="keyword">if</span> (nextMasterKey.getMasterKey().getKeyId() !=</span><br><span class="line">            appAttemptImpl.getAMRMTokenKeyId()) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;The AMRMToken has been rolled-over. Send new AMRMToken back&quot;</span></span><br><span class="line">              + <span class="string">&quot; to application: &quot;</span> + appAttemptId.getApplicationId());</span><br><span class="line">          amrmToken = rmContext.getAMRMTokenSecretManager()</span><br><span class="line">              .createAndGetAMRMToken(appAttemptId);</span><br><span class="line">          appAttemptImpl.setAMRMToken(amrmToken);</span><br><span class="line">        &#125;</span><br><span class="line">        response.setAMRMToken(org.apache.hadoop.yarn.api.records.Token</span><br><span class="line">            .newInstance(amrmToken.getIdentifier(), amrmToken.getKind()</span><br><span class="line">                .toString(), amrmToken.getPassword(), amrmToken.getService()</span><br><span class="line">                .toString()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * As we are updating the response inside the lock <span class="built_in">object</span> so we don<span class="string">&#x27;t</span></span><br><span class="line"><span class="string">       * need to worry about unregister call occurring in between (which</span></span><br><span class="line"><span class="string">       * removes the lock object).</span></span><br><span class="line"><span class="string">       */</span></span><br><span class="line"><span class="string">      response.setResponseId(getNextResponseId(lastResponse.getResponseId()));</span></span><br><span class="line"><span class="string">      lock.setAllocateResponse(response);</span></span><br><span class="line"><span class="string">      return response;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure>

<p>这里重点关注调度相关的主逻辑，因此继续跟进到amsProcessingChain.allocate这个方法中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/AMSProcessingChain.java</span><br><span class="line">  public void allocate(ApplicationAttemptId appAttemptId,</span><br><span class="line">      AllocateRequest request, AllocateResponse response) throws YarnException &#123;</span><br><span class="line"></span><br><span class="line">    // 这里秀了一把设计模式里面的责任链模式</span><br><span class="line">    // 各个服务通过像链表一样串起来，每个的head是下一个，这样AM的请求，会在多个注册的处理类里面依次调用一下</span><br><span class="line">    // 其实目前也只有两种处理器，默认的处理器和OpportunisticContainer的处理器</span><br><span class="line">    this.head.allocate(appAttemptId, request, response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法非常简单，目前先不关注OpportunisticContainer的部分(hadoop 3.0的新特性)，看看历史版本中都存在的主要调度功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java</span><br><span class="line">  public void allocate(ApplicationAttemptId appAttemptId,</span><br><span class="line">      AllocateRequest request, AllocateResponse response) throws YarnException &#123;</span><br><span class="line"></span><br><span class="line">    //这里是一些神圣的检查工作，跳过了</span><br><span class="line"></span><br><span class="line">    // 在AM重新拉起可以继续工作，并且配置为不希望使用上次的container的情况，需要释放一下历史的container</span><br><span class="line">    <span class="keyword">if</span> (!app.getApplicationSubmissionContext()</span><br><span class="line">        .getKeepContainersAcrossApplicationAttempts()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);</span><br><span class="line">      &#125; catch (InvalidContainerReleaseException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Invalid container release by application &quot;</span> + appAttemptId,</span><br><span class="line">            e);</span><br><span class="line">        throw e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 把资源请求变成增加和减少</span><br><span class="line">    <span class="type">List</span>&lt;UpdateContainerError&gt; updateErrors = new ArrayList&lt;&gt;();</span><br><span class="line">    ContainerUpdates containerUpdateRequests =</span><br><span class="line">        RMServerUtils.validateAndSplitUpdateResourceRequests(</span><br><span class="line">            getRmContext(), request, maximumCapacity, updateErrors);</span><br><span class="line"></span><br><span class="line">    Allocation allocation;</span><br><span class="line">    RMAppAttemptState state =</span><br><span class="line">        app.getRMAppAttempt(appAttemptId).getAppAttemptState();</span><br><span class="line">    <span class="keyword">if</span> (state.equals(RMAppAttemptState.FINAL_SAVING) ||</span><br><span class="line">        state.equals(RMAppAttemptState.FINISHING) ||</span><br><span class="line">        app.isAppFinalStateStored()) &#123;</span><br><span class="line">      LOG.warn(appAttemptId + <span class="string">&quot; is in &quot;</span> + state +</span><br><span class="line">          <span class="string">&quot; state, ignore container allocate request.&quot;</span>);</span><br><span class="line">      allocation = EMPTY_ALLOCATION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      //重点关注，当前的这个函数是心跳函数，发新请求和取之前的分配都要进行</span><br><span class="line">      allocation =</span><br><span class="line">          getScheduler().allocate(appAttemptId, ask, release,</span><br><span class="line">              blacklistAdditions, blacklistRemovals,</span><br><span class="line">              containerUpdateRequests);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;blacklist are updated in Scheduler.&quot;</span> +</span><br><span class="line">          <span class="string">&quot;blacklistAdditions: &quot;</span> + blacklistAdditions + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">          <span class="string">&quot;blacklistRemovals: &quot;</span> + blacklistRemovals);</span><br><span class="line">    &#125;</span><br><span class="line">    RMAppAttempt appAttempt = app.getRMAppAttempt(appAttemptId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allocation.getNMTokens() != null &amp;&amp;</span><br><span class="line">        !allocation.getNMTokens().isEmpty()) &#123;</span><br><span class="line">      response.setNMTokens(allocation.getNMTokens());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Notify the AM of container update errors</span><br><span class="line">    ApplicationMasterServiceUtils.addToUpdateContainerErrors(</span><br><span class="line">        response, updateErrors);</span><br><span class="line"></span><br><span class="line">    // update the response <span class="keyword">with</span> the deltas of node status changes</span><br><span class="line">    handleNodeUpdates(app, response);</span><br><span class="line"></span><br><span class="line">    // 这里就是在设置allocateResponse.setAllocatedContainers(allocatedContainers);</span><br><span class="line">    ApplicationMasterServiceUtils.addToAllocatedContainers(</span><br><span class="line">        response, allocation.getContainers());</span><br><span class="line"></span><br><span class="line">    response.setCompletedContainersStatuses(appAttempt</span><br><span class="line">        .pullJustFinishedContainers());</span><br><span class="line">    response.setAvailableResources(allocation.getResourceLimit());</span><br><span class="line"></span><br><span class="line">    addToContainerUpdates(response, allocation,</span><br><span class="line">        ((AbstractYarnScheduler)getScheduler())</span><br><span class="line">            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());</span><br><span class="line"></span><br><span class="line">    response.setNumClusterNodes(getScheduler().getNumClusterNodes());</span><br><span class="line"></span><br><span class="line">    // add collector address <span class="keyword">for</span> this application</span><br><span class="line">    <span class="keyword">if</span> (YarnConfiguration.timelineServiceV2Enabled(</span><br><span class="line">        getRmContext().getYarnConfiguration())) &#123;</span><br><span class="line">      CollectorInfo collectorInfo = app.getCollectorInfo();</span><br><span class="line">      <span class="keyword">if</span> (collectorInfo != null) &#123;</span><br><span class="line">        response.setCollectorInfo(collectorInfo);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // add preemption to the allocateResponse message (<span class="keyword">if</span> <span class="built_in">any</span>)</span><br><span class="line">    response.setPreemptionMessage(generatePreemptionMessage(allocation));</span><br><span class="line"></span><br><span class="line">    // <span class="type">Set</span> application priority</span><br><span class="line">    response.setApplicationPriority(app</span><br><span class="line">        .getApplicationPriority());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的逻辑中，重点关注调度的主线，继续跟进getScheduler().allocate方法，这里的scheduler假设配置是的FairScheduler，那么进入它的allocate方法中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span><br><span class="line">  public Allocation allocate(ApplicationAttemptId appAttemptId,</span><br><span class="line">      <span class="type">List</span>&lt;ResourceRequest&gt; ask, <span class="type">List</span>&lt;ContainerId&gt; release,</span><br><span class="line">      <span class="type">List</span>&lt;String&gt; blacklistAdditions, <span class="type">List</span>&lt;String&gt; blacklistRemovals,</span><br><span class="line">      ContainerUpdates updateRequests) &#123;</span><br><span class="line"></span><br><span class="line">    // 依旧跳过一些神圣的检查工作</span><br><span class="line"></span><br><span class="line">    // 这里处理container的资源动态扩大缩小</span><br><span class="line">    handleContainerUpdates(application, updateRequests);</span><br><span class="line"></span><br><span class="line">    // 再检查一下</span><br><span class="line">    normalizeRequests(ask);</span><br><span class="line"></span><br><span class="line">    // Record container allocation start time</span><br><span class="line">    application.recordContainerRequestTime(getClock().getTime());</span><br><span class="line"></span><br><span class="line">    // 释放AM认为需要释放的container</span><br><span class="line">    releaseContainers(release, application);</span><br><span class="line"></span><br><span class="line">    ReentrantReadWriteLock.WriteLock lock = application.getWriteLock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ask.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(</span><br><span class="line">              <span class="string">&quot;allocate: pre-update&quot;</span> + <span class="string">&quot; applicationAttemptId=&quot;</span> + appAttemptId</span><br><span class="line">                  + <span class="string">&quot; application=&quot;</span> + application.getApplicationId());</span><br><span class="line">        &#125;</span><br><span class="line">        application.showRequests();</span><br><span class="line"></span><br><span class="line">        // 更新应用的申请。(这里前后是加锁的，加锁操作的，一般都是比较重要的点)</span><br><span class="line">        application.updateResourceRequests(ask);</span><br><span class="line"></span><br><span class="line">        application.showRequests();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span>&lt;ContainerId&gt; preemptionContainerIds =</span><br><span class="line">        application.getPreemptionContainerIds();</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(</span><br><span class="line">          <span class="string">&quot;allocate: post-update&quot;</span> + <span class="string">&quot; applicationAttemptId=&quot;</span> + appAttemptId</span><br><span class="line">              + <span class="string">&quot; #ask=&quot;</span> + ask.size() + <span class="string">&quot; reservation= &quot;</span> + application</span><br><span class="line">              .getCurrentReservation());</span><br><span class="line"></span><br><span class="line">      LOG.debug(<span class="string">&quot;Preempting &quot;</span> + preemptionContainerIds.size()</span><br><span class="line">          + <span class="string">&quot; container(s)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    application.updateBlacklist(blacklistAdditions, blacklistRemovals);</span><br><span class="line"></span><br><span class="line">    // 这里是获取最近被分配的containers，其实就是之前RM在心跳时产生的container的最后步骤中放置的container。</span><br><span class="line">    <span class="type">List</span>&lt;Container&gt; newlyAllocatedContainers =</span><br><span class="line">        application.pullNewlyAllocatedContainers();</span><br><span class="line">    // Record container allocation time</span><br><span class="line">    <span class="keyword">if</span> (!(newlyAllocatedContainers.isEmpty())) &#123;</span><br><span class="line">      application.recordContainerAllocationTime(getClock().getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource headroom = application.getHeadroom();</span><br><span class="line">    application.setApplicationHeadroomForMetrics(headroom);</span><br><span class="line">    <span class="keyword">return</span> new Allocation(newlyAllocatedContainers, headroom,</span><br><span class="line">        preemptionContainerIds, null, null,</span><br><span class="line">        application.pullUpdatedNMTokens(), null, null,</span><br><span class="line">        application.pullNewlyPromotedContainers(),</span><br><span class="line">        application.pullNewlyDemotedContainers());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里，AM可以拿到RM分配的container了，整体的过程就是这样。至于AM拿到Container之后，怎么样来使用，各个计算引擎都不太一样，就不再分别介绍了。</p>
<p>至此，整个YARN的调度的过程也就清楚了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/hadoop/" rel="tag"># hadoop</a>
          
            <a href="/tags/yarn/" rel="tag"># yarn</a>
          
            <a href="/tags/scheduler/" rel="tag"># scheduler</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/2018-04-12_%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8E%8B%E7%BC%A9/" rel="next" title="序列化与压缩">
                <i class="fa fa-chevron-left"></i> 序列化与压缩
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/17/Yarn%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%906-Reserve%E6%9C%BA%E5%88%B6/" rel="prev" title="Yarn源码分析6-Reserve机制">
                Yarn源码分析6-Reserve机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yoelee" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:li.ya.kun@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">1. 基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 调度模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E8%B5%84%E6%BA%90%E4%BF%9D%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 资源保证机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E8%B0%83%E5%BA%A6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 调度排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E8%B5%84%E6%BA%90%E6%8A%A2%E5%8D%A0%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 资源抢占模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E9%98%9F%E5%88%97%E5%B1%82%E7%BA%A7%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 队列层级管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-NM%E9%80%9A%E8%BF%87%E5%BF%83%E8%B7%B3%E5%90%91RM%E6%B1%87%E6%8A%A5%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF"><span class="nav-number">2.</span> <span class="nav-text">2.NM通过心跳向RM汇报节点信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-RM%E6%94%B6%E5%88%B0%E5%BF%83%E8%B7%B3"><span class="nav-number">3.</span> <span class="nav-text">3.RM收到心跳</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E8%B0%81%E5%A4%84%E7%90%86RMNodeStatusEvent"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 谁处理RMNodeStatusEvent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%B0%81%E5%A4%84%E7%90%86NodeUpdateSchedulerEvent%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 谁处理NodeUpdateSchedulerEvent事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-AM%E5%90%91RM%E5%8F%91%E5%BF%83%E8%B7%B3%E8%AE%A4%E9%A2%86%E8%B5%84%E6%BA%90"><span class="nav-number">4.</span> <span class="nav-text">4.AM向RM发心跳认领资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-AM%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 AM发起请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-RM%E5%A4%84%E7%90%86AM%E8%AF%B7%E6%B1%82"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 RM处理AM请求</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">亚坤</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
